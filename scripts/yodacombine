#! /usr/bin/env python2

"""\
%prog -o outfile <action>  <yodafile1> <yodafile2> ...

where <action> = add, errsum, quaderrsum, envelope, transfererrors, eigentunes(_up/down)
"""

import yoda, optparse, operator, itertools, sys, copy
from math import sqrt

parser = optparse.OptionParser(usage=__doc__)
parser.add_option('-o', '--output', default='-', dest='OUTPUT_FILE')
opts, args = parser.parse_args()
action=args[0]
filenames=args[1:]


## Put the incoming objects into a dict from each path to a list of histos
scatters_in = {}
for filename in filenames:
    for p, ao in yoda.readYODA(filename).iteritems():
        # print(type(ao), ao.path(), ao.title())
        if 'RAW' in ao.path(): continue 
        if isinstance(ao, yoda.Scatter2D):
            scatter = ao
        elif isinstance(ao, yoda.Histo1D):
            scatter = yoda.Scatter2D(ao.path(), ao.title())
            for bin in ao.bins():
                scatter.addPoint(yoda.Point2D(bin.xMid(), bin.height(), 0.5*bin.xWidth(), bin.heightErr()))
        elif isinstance(ao, yoda.Profile1D):
            scatter = yoda.Scatter2D(ao.path(), ao.title())
            for bin in ao.bins():
                if bin.numEntries() == 0:
                    scatter.addPoint(yoda.Point2D(bin.xMid(), 0, 0.5*bin.xWidth(), 0))
                else:
                    scatter.addPoint(yoda.Point2D(bin.xMid(), bin.mean(), 0.5*bin.xWidth(), bin.stdErr()))
        else:
            print "cannot treat ", ao
            continue
        scatters_in.setdefault(ao.path().replace('/REF', ''), []).append(scatter)

scatters_out = {}
for p, scatters in scatters_in.iteritems():
    # print(p)
    if len(scatters) != len(filenames):
        # print('len(scatters) != len(filenames), continue')
        continue
    for f,scatter in enumerate(scatters):
        if scatter.numPoints() != scatters[0].numPoints():
            print('Warning: number of points not consistent for %s in %s (%d) vs reference %s (%d)', (p, filenames[f], scatter.numPoints(), filenames[0], scatters[0].numPoints()))
    scatters_out[scatters[0].path()] = scatters[0].clone()
    
    for i, point in enumerate(scatters_out[scatters[0].path()].points()):
        if action=="add":
            sum = 0.0
            sumerrminus = 0.0
            sumerrplus = 0.0
            for scatter in scatters:
                tmppoint = scatter.point(i);
                sum += tmppoint.y()
                sumerrminus += tmppoint.yErrs()[0]
                sumerrplus += tmppoint.yErrs()[1]
            point.setY(sum)
            point.setYErrs(sumerrminus, sumerrplus)
        elif action=="errsum":
            sumerrminus = 0.0
            sumerrplus = 0.0
            for scatter in scatters:
                tmppoint = scatter.point(i);
                sumerrminus += tmppoint.yErrs()[0]
                sumerrplus += tmppoint.yErrs()[1]
            point.setYErrs(sumerrminus, sumerrplus)
        elif action=="quaderrsum":
            sum = 0.0
            sumerr2minus = 0.0
            sumerr2plus = 0.0
            for scatter in scatters:
                tmppoint = scatter.point(i);
                sum += tmppoint.y()
                sumerr2minus += tmppoint.yErrs()[0]**2
                sumerr2plus += tmppoint.yErrs()[1]**2
            point.setYErrs(sqrt(sumerr2minus), sqrt(sumerr2plus))
        elif action=="envelope":
            upper = float('-inf')
            lower = float('inf')
            for scatter in scatters:
                val = scatter.point(i).y()
                if val > upper:
                    upper = val
                if val < lower:
                    lower = val
            point.setYErrs(point.y()-lower, upper-point.y())
        elif "eigentunes" in action:
            central = point.y()
            upper = 0.
            lower = 0.
            for scatter in scatters:
                val = scatter.point(i).y()
                if val > central:
                    upper = sqrt(upper**2 + (val-central)**2)
                if val < central:
                    lower = sqrt(lower**2 + (val-central)**2)
            if "up" in action:
                point.setY(central+upper)
            if "down" in action:
                point.setY(central-lower)
            point.setYErrs(lower, upper)
        elif action=="transfererrors":
            point.setY(scatters[0].point(i).y())
            point.setYErrs(scatters[1].point(i).yErrs())
        else:
            print "Unknown action: ",action
            exit(1)

yoda.write(scatters_out.values(), opts.OUTPUT_FILE)

